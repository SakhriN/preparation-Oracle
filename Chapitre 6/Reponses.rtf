{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang12  1. E. Options A and B will not compile because constructors cannot be\par
 called without new. Options C and D will compile but will create a new\par
 object rather than setting the fields in this one. The result is the\par
 program will print 0, not 2, at runtime. Calling an overloaded\par
 constructor, using this(), or a parent constructor, using super(), is\par
 allowed only on the first line of the constructor, making option E\par
 correct and option F incorrect. Finally, option G is incorrect because\par
 the program prints 0 without any changes, not 2.\par
 2. A, B, F. The final modifier can be used with private and static,\par
 making options A and F correct. Marking a private method final is\par
 redundant but allowed. A private method may also be marked\par
 static, making option B correct. Options C, D, and E are incorrect\par
 because methods marked static, private, or final cannot be\par
 overridden; therefore, they cannot be marked abstract.\par
 3. B, C. Overloaded methods have the same method name but a different\par
 signature (the method parameters differ), making option A incorrect.\par
 Overridden instance methods and hidden static methods must have\par
 the same signature (the name and method parameters must match),\par
 making options B and C correct. Overloaded methods can have\par
 different return types, while overridden and hidden methods can have\par
 covariant return types. None of these methods is required to use the\par
 same return type, making options D, E, and F incorrect.\par
 4. F. The code will not compile as is, because the parent class Mammal\par
 does not define a no-argument constructor. For this reason, the first\par
 line of a Platypus constructor should be an explicit call to\par
 super(int), making option F the correct answer. Option E is\par
 incorrect, as line 7 compiles without issue. The sneeze() method in\par
 the Mammal class is marked private, meaning it is not inherited and\par
 therefore is not overridden in the Platypus class. For this reason, the\par
 sneeze() method in the Platypus class is free to define the same\par
 method with any return type.\par
 5. E. The code compiles, making option F incorrect. An instance variable\par
 with the same name as an inherited instance variable is hidden, not\par
overridden. This means that both variables exist, and the one that is\par
 used depends on the location and reference type. Because the main()\par
 method uses a reference type of Speedster to access the numSpots\par
 variable, the variable in the Speedster class, not the Cheetah class,\par
 must be set to 50. Option A is incorrect, as it reassigns the method\par
 parameter to itself. Option B is incorrect, as it assigns the method\par
 parameter the value of the instance variable in Cheetah, which is 0.\par
 Option C is incorrect, as it assigns the value to the instance variable in\par
 Cheetah, not Speedster. Option D is incorrect, as it assigns the\par
 method parameter the value of the instance variable in Speedster,\par
 which is 0. Options A, B, C, and D all print 0 at runtime. Option E is\par
 the correct answer, as it assigns the instance variable numSpots in the\par
 Speedster class a value of 50. The numSpots variable in the\par
 Speedster class is then correctly referenced in the main() method,\par
 printing 50 at runtime.\par
 6. D, E. The Moose class doesn\rquote t compile, as the final variable antlers\par
 is not initialized when it is declared, in an instance initializer, or in a\par
 constructor. Caribou and Reindeer are not immutable because they are\par
 not marked final, which means a subclass could extend them and add\par
 mutable fields. Elk and Deer are both immutable classes since they are\par
 marked final and only include private final members, making\par
 options D and E correct. As shown with Elk, a class doesn\rquote t need to\par
 declare any fields to be considered immutable.\par
 7. A. The code compiles and runs without issue, so options E and F are\par
 incorrect. The Arthropod class defines two overloaded versions of the\par
 printName() method. The printName() method that takes an int\par
 value on line 5 is correctly overridden in the Spider class on line 9.\par
 Remember, an overridden method can have a broader access modifier,\par
 and protected access is broader than package access. Because of\par
 polymorphism, the overridden method replaces the method on all calls,\par
 even if an Arthropod reference variable is used, as is done in the\par
 main() method. For these reasons, the overridden method is called on\par
 lines 14 and 15, printing Spider twice. Note that the short value is\par
 automatically cast to the larger type of int, which then uses the\par
 overridden method. Line 16 calls the overloaded method in the\par
 Arthropod class, as the long value 5L does not match the overridden\par
method, resulting in Arthropod being printed. Therefore, option A is\par
 the correct answer.\par
 8. D. The code compiles without issue. The question is making sure you\par
 know that superclass constructors are called in the same manner in\par
 abstract classes as they are in non-abstract classes. Line 9 calls the\par
 constructor on line 6. The compiler automatically inserts super() as\par
 the first line of the constructor defined on line 6. The program then\par
 calls the constructor on line 3 and prints Wow-. Control then returns to\par
 line 6, and Oh- is printed. Finally, the method call on line 10 uses the\par
 version of fly() in the Pelican class, since it is marked private and\par
 the reference type of var is resolved as Pelican. The final output is\par
 Wow-Oh-Pelican, making option D the correct answer. Remember that\par
 private methods cannot be overridden. If the reference type of chirp\par
 was Bird, then the code would not compile as it would not be\par
 accessible outside the class.\par
 9. B, E. The signature must match exactly, making option A incorrect.\par
 There is no such thing as a covariant signature. An overridden method\par
 must not declare any new checked exceptions or a checked exception\par
 that is broader than the inherited method. For this reason, option B is\par
 correct, and option D is incorrect. Option C is incorrect because an\par
 overridden method may have the same access modifier as the version\par
 in the parent class. Finally, overridden methods must have covariant\par
 return types, and only void is covariant with void, making option E\par
 correct.\par
 10. A, C. Option A is correct, as this(3) calls the constructor declared on\par
 line 5, while this("") calls the constructor declared on line 10. Option\par
 B does not compile, as inserting this() at line 3 results in a compiler\par
 error, since there is no matching constructor. Option C is correct, as\par
 short can be implicitly cast to int, resulting in this((short)1)\par
 calling the constructor declared on line 5. In addition, this(null)\par
 calls the String constructor declared on line 10. Option D does not\par
 compile because inserting super() on line 14 results in an invalid\par
 constructor call. The Howler class does not contain a no-argument\par
 constructor. Option E is also incorrect. Inserting this(2L) at line 3\par
 results in a recursive constructor definition. The compiler detects this\par
 and reports an error. Option F is incorrect, as using super(null) on\par
line 14 does not match any parent constructors. If an explicit cast was\par
 used, such as super((Integer)null), then the code would have\par
 compiled but would throw an exception at runtime during unboxing.\par
 Finally, option G is incorrect because the superclass Howler does not\par
 contain a no-argument constructor. Therefore, the constructor declared\par
 on line 13 will not compile without an explicit call to an overloaded or\par
 parent constructor.\par
 11. C. The code compiles and runs without issue, making options F and G\par
 incorrect. Line 16 initializes a PolarBear instance and assigns it to the\par
 bear reference. The variable declaration and instance initializers are\par
 run first, setting value to tac. The constructor declared on line 5 is\par
 called, resulting in value being set to tacb. Remember, a static\par
 main() method can access private constructors declared in the same\par
 class. Line 17 creates another PolarBear instance, replacing the bear\par
 reference declared on line 16. First, value is initialized to tac as\par
 before. Line 17 calls the constructor declared on line 8, since String is\par
 the narrowest match of a String literal. This constructor then calls the\par
 overloaded constructor declared on line 5, resulting in value being\par
 updated to tacb. Control returns to the previous constructor, with line\par
 10 updating value to tacbf, and making option C the correct answer.\par
 Note that if the constructor declared on line 8 did not exist, then the\par
 constructor on line 12 would match. Finally, the bear reference is\par
 properly cast to PolarBear on line 18, making the value parameter\par
 accessible.\par
 12. C. The code doesn\rquote t compile, so option A is incorrect. The first\par
 compilation error is on line 8. Since Rodent declares at least one\par
 constructor, and it is not a no-argument constructor, Beaver must\par
 declare a constructor with an explicit call to a super() constructor.\par
 Line 9 contains two compilation errors. First, the return types are not\par
 covariant since Number is a supertype, not a subtype, of Integer.\par
 Second, the inherited method is static, but the overridden method is\par
 not, making this an invalid override. The code contains three\par
 compilation errors, although they are limited to two lines, making\par
 option C the correct answer.\par
 13. A, G. The compiler will insert a default no-argument constructor if the\par
 class compiles and does not define any constructors. Options A and G\par
fulfill this requirement, making them the correct answers. The bird()\par
 declaration in option G is a method declaration, not a constructor.\par
 Options B and C do not compile. Since the constructor name does not\par
 match the class name, the compiler treats these as methods with\par
 missing return types. Options D, E, and F all compile, but since they\par
 declare at least one constructor, the compiler does not supply one.\par
 14. B, E, F. A class can only directly extend a single class, making option\par
 A incorrect. A class can implement any number of interfaces, though,\par
 making option B correct. Option C is incorrect because primitive\par
 variables types do not inherit java.lang.Object. If a class extends\par
 another class, then it is a subclass, not a superclass, making option D\par
 incorrect. A class that implements an interface is a subtype of that\par
 interface, making option E correct. Finally, option F is correct as it is\par
 an accurate description of multiple inheritance, which is not permitted\par
 in Java.\par
 15. C. The code does not compile because the isBlind() method in\par
 Nocturnal is not marked abstract and does not contain a method\par
 body. The rest of the lines compile without issue, making option C the\par
 correct answer. If the abstract modifier was added to line 2, then the\par
 code would compile and print false at runtime, making option B the\par
 correct answer.\par
 16. D. The code compiles, so option G is incorrect. Based on order of\par
 initialization, the static components are initialized first, starting with\par
 the Arachnid class, since it is the parent of the Scorpion class, which\par
 initializes the StringBuilder to u. The static initializer in Scorpion\par
 then updates sb to contain uq, which is printed twice by lines 13 and\par
 14 along with spaces separating the values. Next, an instance of\par
 Arachnid is initialized on line 15. There are two instance initializers in\par
 Arachnid, and they run in order, appending cr to the StringBuilder,\par
 resulting in a value of uqcr. An instance of Scorpion is then initialized\par
 on line 16. The instance initializers in the superclass Arachnid run\par
 first, appending cr again and updating the value of sb to uqcrcr.\par
 Finally, the instance initializer in Scorpion runs and appends m. The\par
 program completes with the final value printed being uq uq uqcrcrm,\par
 making option D the correct answer.\par
17. C, F. Calling an overloaded constructor with this() may be used only\par
 as the first line of a constructor, making options A and B incorrect.\par
 Accessing this.variableName can be performed from any instance\par
 method, constructor, or instance initializer, but not from a static\par
 method or static initializer. For this reason, option C is correct, and\par
 option D is incorrect. Option E is tricky. The default constructor is\par
 written by the compiler only if no user-defined constructors were\par
 provided. And this() can only be called from a constructor in the\par
 same class. Since there can be no user-defined constructors in the class\par
 if a default constructor was created, it is impossible for option E to be\par
 true. Since the main() method is in the same class, it can call private\par
 methods in the class, making option F correct.\par
 18. D, F. The eat() method is private in the Mammal class. Since it is not\par
 inherited in the Primate class, it is neither overridden nor overloaded,\par
 making options A and B incorrect. The drink() method in Mammal is\par
 correctly hidden in the Monkey class, as the signature is the same and\par
 both are static, making option D correct and option C incorrect. The\par
 version in the Monkey class throws a new exception, but it is\par
 unchecked; therefore, it is allowed. The dance() method in Mammal is\par
 correctly overloaded in the Monkey class because the signatures are not\par
 the same, making option E incorrect and option F correct. For methods\par
 to be overridden, the signatures must match exactly. Finally, line 12 is\par
 an invalid override and does not compile, as int is not covariant with\par
 void, making options G and H both incorrect.\par
 19. F. The Reptile class defines a constructor, but it is not a no-argument\par
 constructor. Therefore, the Lizard constructor must explicitly call\par
 super(), passing in an int value. For this reason, line 9 does not\par
 compile, and option F is the correct answer. If the Lizard class were\par
 corrected to call the appropriate super() constructor, then the program\par
 would print BALizard at runtime, with the static initializer running\par
 first, followed by the instance initializer, and finally the method call\par
 using the overridden method.\par
 20. E. The program compiles and runs without issue, making options A\par
 through D incorrect. The fly() method is correctly overridden in each\par
 subclass since the signature is the same, the access modifier is less\par
 restrictive, and the return types are covariant. For covariance, Macaw is\par
a subtype of Parrot, which is a subtype of Bird, so overridden return\par
 types are valid. Likewise, the constructors are all implemented\par
 properly, with explicit calls to the parent constructors as needed. Line\par
 19 calls the overridden version of fly() defined in the Macaw class, as\par
 overriding replaces the method regardless of the reference type. This\par
 results in feathers being assigned a value of 3. The Macaw object is\par
 then cast to Parrot, which is allowed because Macaw inherits Parrot.\par
 The feathers variable is visible since it is defined in the Bird class,\par
 and line 19 prints 3, making option E the correct answer.\par
 21. B, G. Immutable objects do not include setter methods, making option\par
 A incorrect. An immutable class must be marked final or contain\par
 only private constructors, so no subclass can extend it and make it\par
 mutable, making option B correct. Options C and E are incorrect, as\par
 immutable classes can contain both instance and static variables.\par
 Option D is incorrect, as marking a class static is not a property of\par
 immutable objects. Option F is incorrect. While an immutable class\par
 may contain only private constructors, this is not a requirement.\par
 Finally, option G is correct. It is allowed for the caller to access data in\par
 mutable elements of an immutable object, provided they have no\par
 ability to modify these elements.\par
 22. D. The code compiles and runs without issue, making option E\par
 incorrect. The Child class overrides the setName() method and hides\par
 the static name variable defined in the inherited Person class. Since\par
 variables are only hidden, not overridden, there are two distinct name\par
 variables accessible, depending on the location and reference type.\par
 Line 8 creates a Child instance, which is implicitly cast to a Person\par
 reference type on line 9. Line 10 uses the Child reference type,\par
 updating Child.name to Elysia. Line 11 uses the Person reference\par
 type, updating Person.name to Sophia. Lines 12 and 13 both call the\par
 overridden setName() instance method declared on line 6. This sets\par
 Child.name to Webby on line 12 and then to Olivia on line 13. The\par
 final values of Child.name and Person.name are Olivia and Sophia,\par
 respectively, making option D the correct answer.\par
 23. B. The program compiles, making option F incorrect. The constructors\par
 are called from the child class upward, but since each line of a\par
 constructor is a call to another constructor, via this() or super(),\par
they are ultimately executed in a top-down manner. On line 29, the\par
 main() method calls the Fennec() constructor declared on line 19.\par
 Remember, integer literals in Java are considered int by default. This\par
 constructor calls the Fox() constructor defined on line 12, which in\par
 turn calls the overloaded Fox() constructor declared on line 11. Since\par
 the constructor on line 11 does not explicitly call a parent constructor,\par
 the compiler inserts a call to the no-argument super() constructor,\par
 which exists on line 3 of the Canine class. Line 3 is then executed,\par
 adding q to the output, and the compiler chain is unwound. Line 11\par
 then executes, adding p, followed by line 14, adding z. Finally, line 21\par
 is executed, and j is added, resulting in a final value for logger of\par
 qpzj and making option B correct. For the exam, remember to follow\par
 constructors from the lowest level upward to determine the correct\par
 pathway, but then execute them from the top down using the\par
 established order.\par
 24. C. The code compiles and runs without issue, making options E and F\par
 incorrect. First, the class is initialized, starting with the superclass\par
 Antelope and then the subclass Gazelle. This involves invoking the\par
 static variable declarations and static initializers. The program first\par
 prints 1, followed by 8. Then we follow the constructor pathway from\par
 the object created on line 14 upward, initializing each class instance\par
 using a top-down approach. Within each class, the instance initializers\par
 are run, followed by the referenced constructors. The Antelope\par
 instance is initialized, printing 24, followed by the Gazelle instance,\par
 printing 93. The final output is 182493, making option C the correct\par
 answer.\par
 25. B, C. Concrete classes are, by definition, not abstract, so option A is\par
 incorrect. A concrete class must implement all inherited abstract\par
 methods, so option B is correct. Concrete classes can be optionally\par
 marked final, so option C is correct. Option D is incorrect; concrete\par
 classes need not be immutable. A concrete subclass only needs to\par
 override the inherited abstract method, not match the declaration\par
 exactly. For example, a covariant return type can be used. For this\par
 reason, option E is incorrect.\par
 26. D. The classes are structured correctly, but the body of the main()\par
 method contains a compiler error. The Orca object is implicitly cast to\par
a Whale reference on line 7. This is permitted because Orca is a\par
 subclass of Whale. By performing the cast, the whale reference on line\par
 8 does not have access to the dive(int\'85 depth) method. For this\par
 reason, line 8 does not compile, making option D correct.\par
}
 