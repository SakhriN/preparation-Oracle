{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang12  1. F. Lines 34 and 35 do not compile because they are missing the pattern\par
 variable type, making option F correct. If a supported type, such as\par
 Integer, were added between the case and variable on each line, then\par
 the code would compile and print 4.\par
 2. A, B, C. A switch expression supports enum values, making option A\par
 correct. It also supports int and byte primitives, including their\par
 wrapper classes Integer and Byte, making options B and C correct. It\par
 does not support the other types.\par
 3. B. The code compiles and runs without issue, so options D, E, and F\par
 are incorrect. Even though two consecutive else statements on lines 7\par
 and 8 look a little odd, they are associated with separate if statements\par
 on lines 5 and 6, respectively. The value of humidity on line 4 is equal\par
 to -4 + 12, which is 8. The first if statement evaluates to true on line\par
 5, so line 6 is executed and evaluates to false. This causes the else\par
 statement on line 7 to run, printing Just Right and making option B\par
 the correct answer.\par
 4. A, D, F. A for-each loop supports arrays, making options A and F\par
 correct. For Double[][], each element of the for-each loop would be a\par
 Double[]. A for-each also supports classes that implement\par
 java.lang.Iterable. Although this includes many of the Collections\par
 Framework classes, not all of them implement java.lang.Iterable.\par
 For this reason, option C is incorrect, and option D is correct. Options\par
 B, E, and G are incorrect, as they do not implement\par
 java.lang.Iterable. Although a String is a list of ordered\par
 characters, the class does not implement the required interface for a\par
 for-each loop.\par
 5. F. The code does not compile because the switch expression requires\par
 all possible case values to be handled, making option F correct. If a\par
 valid default clause was added, then the code would compile and\par
 print Turtle at runtime.\par
 6. E. The second for-each loop contains a continue followed by a\par
 print() statement. Because the continue is not conditional and\par
 always included as part of the body of the for-each loop, the print()\par
statement is not reachable. For this reason, the print() statement does\par
 not compile. As this is the only compilation error, option E is correct.\par
 The other lines of code compile without issue.\par
 7. B, D. Option A is incorrect because on the first iteration, it attempts to\par
 access weather[weather.length] of the nonempty array, which\par
 causes an ArrayIndexOutOfBoundsException to be thrown. Option B\par
 is correct and will print the elements in order. Option C doesn\rquote t\par
 compile as i is undefined in weather[i]. For this to work, the body of\par
 the for-each loop would have to be updated as well. Option D is also\par
 correct and is a common way to print the elements of an array in\par
 reverse order. Option E does not compile and is therefore incorrect.\par
 You can declare multiple elements in a for loop, but the data type\par
 must be listed only once, such as in for (int i=0, j=3; \'85). Finally,\par
 option F is incorrect because the first element of the array is skipped.\par
 Since the conditional expression is checked before the loop is executed\par
 the first time, the first value of i used inside the body of the loop will\par
 be 1.\par
 8. G. The first two pattern matching statements compile without issue.\par
 The variable bat is allowed to be used again, provided it is no longer\par
 in scope. Line 36 does not compile, though. Due to flow scoping, if o\par
 is not a Long, then bat is not in scope in the expression bat <= 20.\par
 Line 38 also does not compile as default cannot be used as part of an\par
 if/else statement. For these two reasons, option G is correct.\par
 9. B, C, E. The code contains a nested loop and a conditional expression\par
 that is executed if the sum of col + row is an even number; otherwise,\par
 count is incremented. Note that options E and F are equivalent to\par
 options B and D, respectively, since unlabeled statements apply to the\par
 most inner loop. Studying the loops, the first time the condition is true\par
 is in the second iteration of the inner loop, when row is 1 and col is 1.\par
 Option A is incorrect because this causes the loop to exit immediately\par
 with count only being set to 1. Options B, C, and E follow the same\par
 pathway. First, count is incremented to 1 on the first inner loop, and\par
 then the inner loop is exited. On the next iteration of the outer loop,\par
 row is 2 and col is 0, so execution exits the inner loop immediately. On\par
 the third iteration of the outer loop, row is 3 and col is 0, so count is\par
 incremented to 2. In the next iteration of the inner loop, the sum is\par
even, so we exit, and our program is complete, making options B, C,\par
 and E each correct. Options D and F are both incorrect, as they cause\par
 the inner and outer loops to execute multiple times, with count having\par
 a value of 5 when done. You don\rquote t need to trace through all the\par
 iterations; just stop when the value of count exceeds 2.\par
 10. E. This code contains numerous compilation errors, making options A\par
 and H incorrect. Line 15 does not compile, as continue cannot be used\par
 inside a switch statement like this. Line 16 is not a compile-time\par
 constant since any int value can be passed as a parameter. Marking it\par
 final does not change this, so it doesn\rquote t compile. Line 18 does not\par
 compile because Sunday is not marked as final. Being effectively\par
 final is insufficient. Finally, line 19 does not compile because\par
 DayOfWeek.MONDAY is not an int value. While switch statements do\par
 support enum values, each case clause must have the same data type\par
 as the switch variable otherDay, which is int. The rest of the lines do\par
 compile. Since exactly four lines do not compile, option E is the\par
 correct answer.\par
 11. A. The code compiles and runs without issue, printing 3 at runtime and\par
 making option A correct. The default clause on line 17 is optional\par
 since all the enum values are accounted for and can be removed\par
 without changing the output.\par
 12. C. Prior to the first iteration, sing = 8, squawk = 2, and notes = 0.\par
 After the iteration of the first loop, sing is updated to 7, squawk to 4,\par
 and notes to the sum of the new values for sing + squawk, 7 + 4 =\par
 11. After the iteration of the second loop, sing is updated to 6, squawk\par
 to 6, and notes to the sum of itself plus the new values for sing +\par
 squawk, 11 + 6 + 6 = 23. On the third iteration of the loop, sing >\par
 squawk evaluates to false, as 6 > 6 is false. The loop ends and the\par
 most recent value of sing, 23, is output, so the correct answer is option\par
 C.\par
 13. F. The code does not compile because case clause uses the logical\par
 complement operator (!), which is not permitted with pattern\par
 matching. If this was removed, then the code would still not compile,\par
 as this clause would dominate the case on line 15, leading to\par
 unreachable code on line 15. For this reason, option F is correct.\par
14. G. This example may look complicated, but the code does not compile.\par
 Line 8 is missing the required parentheses around the boolean\par
 conditional expression. Since the code does not compile and it is not\par
 because of line 6, option G is the correct answer. If line 8 was\par
 corrected with parentheses, then the loop would be executed twice, and\par
 the output would be 11.\par
 15. B, D, F. The code does compile, making option G incorrect. In the first\par
 for-each loop, the right side of the for-each loop has a type of int[],\par
 so each element penguin has a type of int, making option B correct.\par
 In the second for-each loop, ostrich has a type of Character[], so\par
 emu has a data type of Character, making option D correct. In the last\par
 for-each loop, parrots has a data type of List<Integer>. Since the\par
 generic type of Integer is used in the List, macaw will have a data\par
 type of Integer, making option F correct.\par
 16. F. The code does not compile, although not for the reason specified in\par
 option E. The second case clause contains invalid syntax. Each case\par
 clause must have the keyword case\f1\emdash in other words, you cannot chain\par
 them with a colon (:). For this reason, option F is the correct answer.\par
 This line could have been fixed to say case \rquote B\rquote , \rquote C\rquote  or by adding the\par
 case keyword before \rquote C\rquote ; then the rest of the code would have\par
 compiled and printed great good at runtime.\par
 17. A, B, D. To print items in the wolf array in reverse order, the code\par
 needs to start with wolf[wolf.length-1] and end with wolf[0].\par
 Option A accomplishes this and is the first correct answer. Option B is\par
 also correct and is one of the most common ways a reverse loop is\par
 written. The termination condition is often m>=0 or m>-1, and both are\par
 correct. Options C and F each cause an\par
 ArrayIndexOutOfBoundsException at runtime since both read from\par
 wolf[wolf.length] first, with an index that is passed the length of the\par
 0-based array wolf. The form of option C would be successful if the\par
 value was changed to wolf[wolf.length-z-1]. Option D is also\par
 correct, as the j is extraneous and can be ignored in this example.\par
 Finally, option E is incorrect and produces an infinite loop, as w is\par
 repeatedly set to r-1, in this case 4, on every loop iteration. Since the\par
 update statement has no effect after the first iteration, the condition is\par
 never met, and the loop never terminates.\par
18. B, E. The code compiles without issue and prints two distinct numbers\par
 at runtime, so options G and H are incorrect. The first loop executes a\par
 total of five times, with the loop ending when participants has a\par
 value of 10. For this reason, option E is correct. In the second loop,\par
 animals starts out not less than or equal to 1, but since it is a do/while\par
 loop, it executes at least once. In this manner, animals takes on a value\par
 of 3 and the loop terminates, making option B correct. Finally, the last\par
 loop executes a total of two times, with performers starting with -1,\par
 going to 1 at the end of the first loop, and then ending with a value of 3\par
 after the second loop, which breaks the loop. This makes option B a\par
 correct answer twice over.\par
 19. E. The variable snake is declared within the body of the do/while\par
 statement, so it is out of scope on line 7. For this reason, option E is\par
 the correct answer. If snake were declared before line 3 with a value of\par
 1, then the output would have been 1 2 3 4 5 -5.0, and option G\par
 would have been the correct answer.\par
 20. A, E. The most important thing to notice when reading this code is that\par
 the innermost loop is an infinite loop. Therefore, you are looking for\par
 solutions that skip the innermost loop entirely or that exit that loop.\par
 Option A is correct, as break L2 on line 8 causes the second inner\par
 loop to exit every time it is entered, skipping the innermost loop\par
 entirely. For option B, the first continue on line 8 causes the execution\par
 to skip the innermost loop on the first iteration of the second loop but\par
 not the second iteration of the second loop. The innermost loop is\par
 executed, and with continue on line 12, it produces an infinite loop at\par
 runtime, making option B incorrect. Option C is incorrect because it\par
 contains a compiler error. The label L3 is not visible outside its loop.\par
 Option D is incorrect, as it is equivalent to option B since the\par
 unlabeled break and continue apply to the nearest loop and therefore\par
 produce an infinite loop at runtime. Like option A, the continue L2 on\par
 line 8 allows the innermost loop to be executed the second time the\par
 second loop is called. The continue L2 on line 12 exits the infinite\par
 loop, though, causing control to return to the second loop. Since the\par
 first and second loops terminate, the code terminates, and option E is a\par
 correct answer.\par
21. D. Line 23 does not compile because it is missing a yield statement.\par
 Line 24 does not compile because it contains an extra semicolon at the\par
 end. Finally, lines 25 and 26 do not compile because they use the same\par
 case value. At least one of them would need to be changed for the\par
 code to compile. Since three lines need to be corrected, option D is\par
 correct.\par
 22. E. The code compiles without issue, making options F and G incorrect.\par
 Remember, var is supported in both switch and while loops, provided\par
 the compiler determines that the type is compatible with these\par
 statements. In addition, the variable one is allowed in a case clause\par
 because it is a final local variable, making it a compile-time constant.\par
 The value of tailFeathers is 3, which matches the second case\par
 clause, making 5 the first output. The while loop is executed twice,\par
 with the pre-decrement operator (--) modifying the value of\par
 tailFeathers from 3 to 2 and then to 1 on the second loop. For this\par
 reason, the final output is 5 2 1, making option E the correct answer.\par
 23. F. Line 19 starts with an else statement, but there is no preceding if\par
 statement that it matches. For this reason, line 19 does not compile,\par
 making option F the correct answer. If the else keyword was removed\par
 from line 19, then the code snippet would print Success.\par
 24. B. Since this is a pattern matching switch statement, the case\par
 branches are evaluated in the order in which they appear. In particular,\par
 each branch does not dominate the ones after it, so the code compiles\par
 without issue. If either of the when clauses were removed from their\par
 accompanying case clause, then the code would not compile. The first\par
 branch is skipped because Closed does not match Open. The second\par
 one matches, resulting in 20 being printed at runtime and making\par
 option B correct.\par
 25. D. The code compiles without issue, so option F is incorrect. The\par
 viola variable created on line 8 is never used and can be ignored. If it\par
 had been used as the case value on line 15, it would have caused a\par
 compilation error since it is not marked final. Since "violin" and\par
 "VIOLIN" are not an exact match, the default branch of the switch\par
 statement is executed at runtime. This execution path increments p a\par
total of three times, bringing the final value of p to 2 and making\par
 option D the correct answer.\par
 26. F. The code snippet does not contain any compilation errors, so options\par
 D and E are incorrect. There is a problem with this code snippet,\par
 though. While it may seem complicated, the key is to notice that the\par
 variable r is updated outside of the do/while loop. This is allowed\par
 from a compilation standpoint, since it is defined before the loop, but it\par
 means the innermost loop never breaks the termination condition r <=\par
 1. At runtime, this will produce an infinite loop the first time the\par
 innermost loop is entered, making option F the correct answer.\par
 27. D. The code compiles and runs without issue, as every case block\par
 contains a yield statement. The second case block contains two paths\par
 which both end in a yield statement. At runtime, the code prints Blue,\par
 making option D correct.\par
 28. F. Based on flow scoping, guppy is in scope after lines 41\endash 42 if the\par
 type is not a String. In this case, line 43 declares a variable guppy that\par
 is a duplicate of the previously defined local variable defined on line\par
 41. For this reason, the code does not compile, and option F is correct.\par
 If a different variable name was used on line 43, then the code would\par
 compile and print Swim! at runtime with the specified input.\par
 29. C. Since the pre-increment operator was used, the first value that will\par
 be displayed is -1, so options A and B are incorrect. On the second-to\par
last iteration of the loop, y will be incremented to 5, and the loop will\par
 output 5. The loop will continue since 5 <= 5 is true, and on the last\par
 iteration, 6 will be output. At the end of this last iteration, the boolean\par
 expression 6 <= 5 will evaluate to false, and the loop will terminate.\par
 Since 6 was the last value output by the loop, the answer is option C.\par
 30. E. On line 43, the semicolon should be after the yield statement, not\par
 outside the brace. Line 48 is missing a semicolon after the return\par
 statement containing the switch expression. For these reasons, at least\par
 two lines must be corrected. Next, lines 43, 44, and 45 do not compile\par
 because the numeric values are not compatible with the reference type\par
 for Object. We can fix this by changing line 41 to pass speed as a\par
 compatible type, such as Integer. Finally, the default clause on line\par
 46 dominates the proceeding case null on line 47. Removing line 47\par
fixes this issue, as case null is not required. Since we can get the\par
 code to compile by changing or removing four lines, option E is the\par
 correct answer.\f0\par
}
 