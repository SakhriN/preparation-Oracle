{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang12 1. B, D, E. Iguana does not compile, as it declares a static field with the\par
 same name as an instance field. Records are implicitly final and\par
 cannot be marked abstract, which is why Gecko compiles and\par
 Chameleon does not, making option B correct. Notice in Gecko that\par
 records are not required to declare any fields. BeardedDragon also\par
 compiles, as records may override any accessor methods, making\par
 option D correct. Reptile compiles as it contains a valid compact\par
 constructor, making option E correct. Newt does not compile because it\par
 cannot extend another record. It also does not compile because the\par
 compact constructor tries to read this.age, which is not permitted.\par
 2. A, B, D, E. The code compiles without issue, so option G is incorrect.\par
 The blank can be filled with any class or interface that is a supertype\par
 of TurtleFrog. Option A is the direct superclass of TurtleFrog, and\par
 option B is the same class, so both are correct. BrazilianHornedFrog\par
 is not a superclass of TurtleFrog, so option C is incorrect. TurtleFrog\par
 inherits the CanHop interface, so option D is correct. Option E is also\par
 correct, as var is permitted when the type is known. Finally, Long is an\par
 unrelated class that is not a superclass of TurtleFrog and is therefore\par
 incorrect.\par
 3. D. When an enum contains only a list of values, the semicolon (;) after\par
 the list is optional. When an enum contains any other members, such\par
 as a constructor or variable, the semicolon is required. For this reason,\par
 line 13 does not compile. Line 14 also does not compile, as enum\par
 constructors are implicitly private and cannot be declared as public\par
 or protected. For this reason, option D is correct. If these two issues\par
 were corrected, then the program would print 0 1 0 at runtime.\par
 4. C. A class extending a sealed class must be marked final, sealed, or\par
 non-sealed. Since Armadillo is missing a modifier, the code does not\par
 compile, and option C is correct.\par
 5. E. First, the declarations of HasExoskeleton and Insect are correct\par
 and do not contain any errors, making options C and D incorrect. The\par
 concrete class Beetle extends Insect and inherits two abstract\par
 methods, getNumberOfSections() and getNumberOfLegs(). The\par
Beetle class includes an overloaded version of\par
 getNumberOfSections() that takes an int value. The method\par
 declaration is valid, making option F incorrect, although it does not\par
 satisfy the abstract method requirement inherited from\par
 HasExoskeleton. For this reason, only one of the two abstract methods\par
 is properly overridden. The Beetle class therefore does not compile,\par
 and option E is correct.\par
 6. D, E. Line 4 does not compile, since an abstract method cannot\par
 include a body. Line 7 also does not compile because the wrong\par
 keyword is used. A class implements an interface; it does not extend it.\par
 For these reasons, options D and E are correct.\par
 7. E. The inherited interface method getNumOfGills(int) is implicitly\par
 public; therefore, it must be declared public in any concrete class that\par
 implements the interface. Since the method uses the package (default)\par
 modifier in the ClownFish class, line 6 does not compile, making\par
 option E the correct answer. If the method declaration were corrected\par
 to include public on line 6, then the program would compile and print\par
 15 at runtime, and option B would be the correct answer.\par
 8. B, E, G. Options A and F do not compile because they are not\par
 compatible with List<String>. Option C does not compile because\par
 the reference type of w is Object, which doesn\rquote t have an animal()\par
 method. Option D does not compile because the variable i is used\par
 twice in the same pattern matching statement. Option H does not\par
 compile because you can\rquote t use null in a pattern matching statement.\par
 Options B, E, and G correctly compile and print true at runtime.\par
 9. A, E, F. The setSnake() method requires an instance of Snake. Cobra\par
 is a direct subclass, while GardenSnake is an indirect subclass. For\par
 these reasons, options A and E are correct. Option B is incorrect\par
 because Snake is abstract and requires a concrete subclass for\par
 instantiation. Option C is incorrect because Object is a supertype of\par
 Snake, not a subtype. Option D is incorrect as String is an unrelated\par
 class and does not inherit Snake. Finally, a null value can always be\par
 passed as an object value, regardless of type, so option F is also\par
 correct.\par
10. A, B, C, E. Walk declares a private method that is not inherited in any\par
 of its subtypes. For this reason, any valid class is supported on line X,\par
 making options A, B, and C correct. Line Z is more restrictive, with\par
 only ArrayList or subtypes of ArrayList supported, making option E\par
 correct.\par
 11. B. Inner classes can contain static variables, so the code compiles.\par
 Remember that private constructors can be used by any methods\par
 within the outer class. The butter reference on line 8 refers to the\par
 inner class variable defined on line 6, with the output being 10 at\par
 runtime, and making option B correct.\par
 12. A, D, E, F. The code compiles, making options G, H, and I incorrect.\par
 The hiss() method is an instance member, so it can access any visible\par
 static members inside itself or the outer class, making option F\par
 correct. It can also access instance variables and methods within the\par
 record, making options A, D, and E correct. Because nested records\par
 are inherently static, it cannot access body or tail, which are\par
 instance members of the outer class, making options B and C incorrect.\par
 13. G. The code compiles without issue, so options E and F are incorrect.\par
 It prints a NullPointerException at runtime, making option G\par
 correct.\par
 14. A, C, E. A sealed interface restricts which interfaces may extend it, or\par
 which classes may implement it, making options A and E correct.\par
 Option B is incorrect. For example, a non-sealed subclass allows\par
 classes not listed in the permits clause to indirectly extend the sealed\par
 class. Option C is correct. While a sealed class is commonly extended\par
 by a subclass marked final, it can also be extended by a sealed or\par
 non-sealed subclass marked abstract. Option D is incorrect, as the\par
 modifier is non-sealed, not nonsealed. Finally, option F is incorrect,\par
 as sealed classes can contain nested subclasses.\par
 15. F. Trick question\f1\emdash the code does not compile! For this reason, option\par
 F is correct. The Spirit class is marked final, so it cannot be\par
 extended. The main() method uses an anonymous class that inherits\par
 from Spirit, which is not allowed. If Spirit were not marked final,\par
 then option C would be correct. Option A would print Booo!!!, while\par
 options B, D, and E would not compile for various reasons.\par
16. E. The OstrichWrangler class is a static nested class; therefore, it\par
 cannot access the instance member count. For this reason, line 5 does\par
 not compile, and option E is correct.\par
 17. E, G. Lines 2 and 3 compile with interface variables implicitly public,\par
 static, and final. Line 4 also compiles, as static methods are\par
 implicitly public. Line 5 does not compile, making option E correct.\par
 Non-static interface methods with a body must be explicitly marked\par
 private or default. Line 6 compiles, with the public modifier being\par
 added by the compiler. Line 7 does not compile, as interfaces do not\par
 have protected members, making option G correct. Finally, line 8\par
 compiles without issue.\par
 18. E. Diet is an inner class, which requires an instance of Deer to\par
 instantiate. Since the main() method is static, there is no such\par
 instance. Therefore, the main() method does not compile, and option E\par
 is correct. If a reference to Deer were used, such as calling new\par
 Deer().new Diet(), then the code would compile and print b at\par
 runtime.\par
 19. F. The isHealthy() method is marked abstract in the enum;\par
 therefore, it must be implemented in each enum value declaration.\par
 Since only INSECTS implements it, the code does not compile, making\par
 option F correct.\par
 20. H. The record declarations compile but the switch expression does\par
 not, making option H correct. First, the second case statement does not\par
 compile, as double is not compatible with Double. Next, the pattern\par
 matching case statement on line 22 dominates the ones on lines 23\endash 25.\par
 If three of them were to be removed (including the second one), then\par
 the code would compile and print the value associated with the\par
 remaining one.\par
 21. F. The record defines an overloaded constructor using parentheses, not\par
 a compact one. For this reason, the first line must be a call to another\par
 constructor, such as this(500, "Acme", LocalDate.now()). For this\par
 reason, the code does not compile and option F is correct.\par
 22. C, D, G. Option C correctly creates an instance of an inner class Cub\par
 using an instance of the outer class Lion. Options A, B, E, and H use\par
incorrect syntax for creating an instance of the Cub class. Options D\par
 and G correctly create an instance of the static nested Den class,\par
 which does not require an instance of Lion, while option F uses invalid\par
 syntax.\par
 23. D. First, if a class or interface inherits two interfaces containing\par
 default methods with the same signature, it must override the method\par
 with its own implementation. The Penguin class does this correctly, so\par
 option E is incorrect. The way to access an inherited default method\par
 is by using the syntax Swim.super.perform(), making option D\par
 correct. We agree that the syntax is bizarre, but you need to learn it.\par
 Options A, B, and C are incorrect and result in compiler errors.\par
 24. B, E. Line 3 does not compile because the static method hunt()\par
 cannot access an abstract instance method getName(), making option\par
 B correct. Line 6 does not compile because the private static\par
 method sneak() cannot access the private instance method roar(),\par
 making option E correct. The rest of the lines compile without issue.\par
 25. B. Zebra.this.x is the correct way to refer to x in the Zebra class.\par
 Line 5 defines an abstract local class within a method, while line 11\par
 defines a concrete anonymous class that extends the Stripes class.\par
 The code compiles without issue and prints x is 24 at runtime,\par
 making option B the correct answer.\par
 26. C. The code compiles and runs without issue. The stand() method is\par
 overridden on line 24, so the code prints 3 (-1 + 4) at runtime, making\par
 option C correct. Note that unlike records, enums can have mutable\par
 members, so the modification of legs on line 34 is permitted (albeit\par
 not recommended!).\par
 27. B, C, D, G. The compiler inserts an accessor for each field, a\par
 constructor containing all of the fields in the order they are declared,\par
 and useful implementations of equals(), hashCode(), and\par
 toString(), making options B, C, D, and G correct. Option A is\par
 incorrect, as the compiler would only insert a no-argument constructor\par
 if the record had no fields. Option E is incorrect, as records are\par
 immutable. Option F is also incorrect and not a property of records.\par
28. A, B, D. Camel does not compile because the travel() method does\par
 not declare a body, nor is it marked abstract, making option A\par
 correct. EatsGrass also does not compile because an interface method\par
 cannot be marked both private and abstract, making option B\par
 correct. Finally, Eagle does not compile because it declares an abstract\par
 method soar() in a concrete class, making option D correct. The other\par
 classes compile without issue.\par
 29. F. The code does not compile, so options A through options C are\par
 incorrect. Both lines 5 and 12 do not compile, as this() is used\par
 instead of this. Remember, this() refers to calling a constructor,\par
 whereas this is a reference to the current instance. Next, the compiler\par
 does not allow casting to an unrelated class type. Since Orangutan is\par
 not a subclass of Primate, the cast on line 15 is invalid, and the code\par
 does not compile. Due to these three lines containing compilation\par
 errors, option F is the correct answer.\par
 30. C, E. Bird and its nested Flamingo subclass compile without issue.\par
 The permits clause is optional if the subclass is nested or declared in\par
 the same file. For this reason, Monkey and its subclass Mandrill also\par
 compile without issue. EmperorTamarin does not compile, as it is\par
 missing a non-sealed, sealed, or final modifier, making option C\par
 correct. Friendly also does not compile, since it lists a subclass Silly\par
 that does not extend it, making option E correct. While the permits\par
 clause is optional, the extends clause is not. Silly compiles just fine.\par
 Even though it does not extend Friendly, the compiler error is in the\par
 sealed class.\f0\par
}
 