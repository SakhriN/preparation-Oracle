{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang12 1. What could be the output of the following?\par
 var stream = Stream.iterate("", (s) -> s + "1");\par
 System.out.println(stream.limit(2).map(x -> x + "2"));\par
A. 12112\par
 B. 212\par
 C. 212112\par
 D. java.util.stream.ReferencePipeline$3@4517d9a3\par
 E. The code does not compile.\par
 F. An exception is thrown.\par
 G. The code hangs.\par
 2. What could be the output of the following?\par
 Predicate<String> predicate = s -> s.startsWith("g");\par
 var stream1 = Stream.generate(() -> "growl!");\par
 var stream2 = Stream.generate(() -> "growl!");\par
 var b1 = stream1.anyMatch(predicate);\par
 var b2 = stream2.allMatch(predicate);\par
 System.out.println(b1 + " " + b2);\par
 A. true false\par
 B. true true\par
 C. java.util.stream.ReferencePipeline$3@4517d9a3\par
 D. The code does not compile.\par
 E. An exception is thrown.\par
 F. The code hangs.\par
 3. What could be the output of the following?\par
 Predicate<String> predicate = s -> s.length()> 3;\par
 var stream = Stream.iterate("-",\par
    s -> ! s.isEmpty(), (s) -> s + s);\par
 var b1 = stream.noneMatch(predicate);\par
 var b2 = stream.anyMatch(predicate);\par
 System.out.println(b1 + " " + b2);\par
 A. false false\par
 B. false true\par
 C. java.util.stream.ReferencePipeline$3@4517d9a3\par
 D. The code does not compile.\par
 E. An exception is thrown.\par
 F. The code hangs.\par
 4. Which are true statements about terminal operations in a stream that runs successfully?\par
 (Choose all that apply.)\par
 A. At most one terminal operation can exist in a stream pipeline.\par
 B. Terminal operations are a required part of the stream pipeline in order to get a result.\par
 C. Terminal operations have Stream as the return type.\par
D. The peek() method is an example of a terminal operation.\par
 E. The referenced Stream may be used after calling a terminal operation.\par
 5. Which of the following sets result to 8.0? (Choose all that apply.)\par
 A. \par
double result = LongStream.of(6L, 8L, 10L)\par
   .mapToInt(x -> (int) x)\par
   .collect(Collectors.groupingBy(x -> x))\par
   .keySet()\par
   .stream()\par
   .collect(Collectors.averagingInt(x -> x));\par
 B. \par
C. \par
D. \par
E. \par
F. \par
double result = LongStream.of(6L, 8L, 10L)\par
   .mapToInt(x -> x)\par
   .boxed()\par
   .collect(Collectors.groupingBy(x -> x))\par
   .keySet()\par
   .stream()\par
   .collect(Collectors.averagingInt(x -> x));\par
 double result = LongStream.of(6L, 8L, 10L)\par
   .mapToInt(x -> (int) x)\par
   .boxed()\par
   .collect(Collectors.groupingBy(x -> x))\par
   .keySet()\par
    .stream()\par
   .collect(Collectors.averagingInt(x -> x));\par
 double result = LongStream.of(6L, 8L, 10L)\par
   .mapToInt(x -> (int) x)\par
   .collect(Collectors.groupingBy(x -> x, Collectors.toSet()))\par
   .keySet()\par
   .stream()\par
   .collect(Collectors.averagingInt(x -> x));\par
 double result = LongStream.of(6L, 8L, 10L)\par
   .mapToInt(x -> x)\par
   .boxed()\par
   .collect(Collectors.groupingBy(x -> x, Collectors.toSet()))\par
   .keySet()\par
   .stream()\par
   .collect(Collectors.averagingInt(x -> x));\par
 double result = LongStream.of(6L, 8L, 10L)\par
   .mapToInt(x -> (int) x)\par
   .boxed()\par
   .collect(Collectors.groupingBy(x -> x, Collectors.toSet()))\par
   .keySet()\par
   .stream()\par
   .collect(Collectors.averagingInt(x -> x));\par
 6. Which of the following methods can fill in the blank so that the code prints out false?\par
 var s = Stream.generate(() -> "meow");\par
 var match = s.__________(String::isEmpty);\par
 System.out.println(match);\par
 A. Only allMatch\par
 B. Only anyMatch\par
 C. Only noneMatch\par
 D. Both allMatch and anyMatch\par
 E. Both allMatch and noneMatch\par
 F. None of the above\par
 7. We have a method that returns a sorted list without changing the original. We want to\par
 rewrite it. Which of the following pairs can fill in the blanks in refactored() to do the\par
 same with streams?\par
 private static List<String> sort(List<String> list) \{\par
   var copy = new ArrayList<String>(list);\par
   Collections.sort(copy, (a, b) -> b.compareTo(a));\par
   return copy;\par
 \}\par
 private static List<String> refactored(List<String> list) \{\par
   return list.stream()\par
      ._______((a, b) -> b.compareTo(a))\par
      .__________;\par
 \}\par
 A. compare and toList()\par
 B. compare and sort()\par
 C. compareTo and toList()\par
 D. compareTo and sort()\par
 E. sorted and collect()\par
 F. sorted and collect(Collectors.toList())\par
 8. Which of the following are true given this declaration? (Choose all that apply.)\par
 var is = IntStream.empty();\par
 A. is.average() returns the type int.\par
 B. is.average() returns the type OptionalInt.\par
 C. is.findAny() returns the type int.\par
 D. is.findAny() returns the type OptionalInt.\par
 E. is.sum() returns the type int.\par
F. is.sum() returns the type OptionalInt.\par
 9. Which of the following can we add after line 6 for the code to run without error and not\par
 produce any output? (Choose all that apply.)\par
 4: var stream = LongStream.of(1, 2, 3);\par
 5: var opt = stream.map(n -> n * 10)\par
 6:    .filter(n -> n < 5).findFirst();\par
 A. \par
B. \par
C. \par
D. \par
if (opt.isPresent())\par
   System.out.println(opt.get());\par
 if (opt.isPresent())\par
   System.out.println(opt.getAsLong());\par
 opt.ifPresent(System.out.println);\par
 opt.ifPresent(System.out::println);\par
 E. None of these; the code does not compile.\par
 F. None of these; line 6 throws an exception at runtime.\par
 10. Given the four statements (L, M, N, O), select the order that would cause the code to output\par
 10 lines.\par
 Stream.generate(() -> "1")\par
   L: .filter(x -> x.length()> 1)\par
   M: .forEach(System.out::println)\par
   N: .limit(10)\par
   O: .peek(System.out::println)\par
 ;\par
 A. L, N\par
 B. L, N, O\par
 C. L, N, M\par
 D. L, N, M, O\par
 E. L, O, M\par
 F. N, M\par
 G. N, O\par
 11. What changes need to be made together for this code to print the string 12345? (Choose all\par
 that apply.)\par
 Stream.iterate(1, x -> x++)\par
   .limit(5).map(x -> x)\par
   .collect(Collectors.joining());\par
A. Changing Collectors.joining() to Collectors.joining(",")\par
 B. Changing map(x -> x) to map(x -> "" + x)\par
 C. Changing x -> x++ to x -> ++x\par
 D. Adding .forEach(System.out::print) after the call to collect()\par
 E. Wrapping the entire line in a System.out.print statement\par
 F. None of the above; the code already prints 12345\par
 12. Which is true of the following code?\par
 Set<String> birds = Set.of("oriole", "flamingo");\par
 Stream.concat(birds.stream(), birds.stream(), birds.stream())\par
   .sorted()       // line X\par
   .distinct()\par
   .findAny()\par
   .ifPresent(System.out::println);\par
 A. It is guaranteed to print flamingo as is and when line X is removed.\par
 B. It is guaranteed to print oriole as is and when line X is removed.\par
 C. It is guaranteed to print flamingo as is, but not when line X is removed.\par
 D. It is guaranteed to print oriole as is, but not when line X is removed.\par
 E. The output may vary as is.\par
 F. The code does not compile.\par
 G. It throws an exception because the same list is used as the source for multiple streams.\par
 13. Which of the following is true?\par
 List<Integer> x1 = List.of(1, 2, 3);\par
 List<Integer> x2 = List.of(4, 5, 6);\par
 List<Integer> x3 = List.of();\par
 Stream.of(x1, x2, x3).map(x -> x + 1)\par
   .flatMap(x -> x.stream())\par
   .forEach(System.out::print);\par
 A. The code compiles and prints 123456.\par
 B. The code compiles and prints 234567.\par
 C. The code compiles but does not print anything.\par
 D. The code compiles but prints stream references.\par
 E. The code runs infinitely.\par
 F. The code does not compile.\par
 G. The code throws an exception.\par
 14. Which of the following are true? (Choose all that apply.)\par
 4: Stream<Integer> s = Stream.of(1);\par
 5: IntStream is = s.boxed();\par
 6: DoubleStream ds = s.mapToDouble(x -> x);\par
7: Stream<Integer> s2 = ds.mapToInt(x -> x);\par
 8: s2.forEach(System.out::print);\par
 A. Line 4 causes a compiler error.\par
 B. Line 5 causes a compiler error.\par
 C. Line 6 causes a compiler error.\par
 D. Line 7 causes a compiler error.\par
 E. Line 8 causes a compiler error.\par
 F. The code compiles but throws an exception at runtime.\par
 G. The code compiles and prints 1.\par
 15. Given the generic type String, the partitioningBy() collector creates a Map<Boolean,\par
 List<String>> when passed to collect() by default. When a downstream collector is\par
 passed to partitioningBy(), which return types can be created? (Choose all that apply.)\par
 A. Map<boolean, List<String>>\par
 B. Map<Boolean, List<String>>\par
 C. Map<Boolean, Map<String>>\par
 D. Map<Boolean, Set<String>>\par
 E. Map<Long, TreeSet<String>>\par
 F. None of the above\par
 16. Which of the following statements are true about this code? (Choose all that apply.)\par
 20: Predicate<String> empty = String::isEmpty;\par
 21: Predicate<String> notEmpty = empty.negate();\par
 22:\par
 23: var result = Stream.generate(() -> "")\par
 24:    .limit(10)\par
 25:    .filter(notEmpty)\par
 26:    .collect(Collectors.groupingBy(k -> k))\par
 27:    .entrySet()\par
 28:    .stream()\par
 29:    .map(Entry::getValue)\par
 30:    .flatMap(Collection::stream)\par
 31:    .collect(Collectors.partitioningBy(notEmpty));\par
 32: System.out.println(result);\par
 A. It outputs \{\}.\par
 B. It outputs \{false=[], true=[]\}.\par
 C. If we changed line 31 from partitioningBy(notEmpty) to groupingBy(n -> n), it\par
 would output \{\}.\par
 D. If we changed line 31 from partitioningBy(notEmpty) to groupingBy(n -> n), it\par
 would output \{false=[], true=[]\}.\par
 E. The code does not compile.\par
 F. The code compiles but does not terminate at runtime.\par
17. What is the result of the following?\par
 var s = DoubleStream.of(1.2, 2.4);\par
 s.peek(System.out::println).filter(x -> x> 2).count();\par
 A. 1\par
 B. 2\par
 C. 2.4\par
 D. 1.2 and 2.4\par
 E. There is no output.\par
 F. The code does not compile.\par
 G. An exception is thrown.\par
 18. What is the output of the following?\par
 11: public class Paging \{\par
 12:    record Sesame(String name, boolean human)  \{\par
 13:       @Override public String toString() \{\par
 14:          return name();\par
 15:       \}\par
 16:    \} \par
17:    record Page(List<Sesame> list, long count)  \{\}\par
 18:\par
 19:    public static void main(String[] args) \{\par
 20:       var monsters = Stream.of(new Sesame("Elmo", false));\par
 21:       var people = Stream.of(new Sesame("Abby", true));\par
 22:       printPage(monsters, people);\par
 23:    \}\par
 24:\par
 25:    private static void printPage(Stream<Sesame> monsters, \par
26:          Stream<Sesame> people) \{\par
 27:       Page page = Stream.concat(monsters, people)\par
 28:          .collect(Collectors.teeing(\par
 29:             Collectors.filtering(s -> s.name().startsWith("E"), \par
30:                Collectors.toList()),\par
 31:             Collectors.counting(),\par
 32:             (l, c) -> new Page(l, c)));\par
 33:       System.out.println(page);\par
 34:    \} \}\par
 A. Page[list=[Abby], count=1]\par
 B. Page[list=[Abby], count=2]\par
 C. Page[list=[Elmo], count=1]\par
 D. Page[list=[Elmo], count=2]\par
 E. The code does not compile due to Stream.concat().\par
 F. The code does not compile due to Collectors.teeing().\par
 G. The code does not compile for another reason.\par
 19. What is the simplest way of rewriting this code?\par
List<Integer> x = IntStream.range(1, 6)\par
   .mapToObj(i -> i)\par
   .collect(Collectors.toList());\par
 x.forEach(System.out::println);\par
 A. \par
B. \par
C. \par
IntStream.range(1, 6);\par
 IntStream.range(1, 6)\par
   .forEach(System.out::println);\par
 IntStream.range(1, 6)\par
    .mapToObj(i -> i)\par
    .forEach(System.out::println);\par
 D. None of the above is equivalent.\par
 E. The provided code does not compile.\par
 20. Which of the following throw an exception when an Optional is empty? (Choose all that\par
 apply.)\par
 A. opt.orElse("");\par
 B. opt.orElseGet(() -> "");\par
 C. opt.orElseThrow();\par
 D. opt.orElseThrow(() -> throw new Exception());\par
 E. opt.orElseThrow(RuntimeException::new);\par
 F. opt.get();\par
 G. opt.get("");\par
 21. What is the output of the following?\par
 var spliterator = Stream.generate(() -> "x")\par
   .spliterator();\par
 spliterator.tryAdvance(System.out::print);  \par
var split = spliterator.trySplit();\par
 split.tryAdvance(System.out::print);\par
 A. x\par
 B. xx\par
 C. A long list of x\rquote s.\par
 D. There is no output.\par
 E. The code does not compile.\par
 F. The code compiles but does not terminate at runtime.\par
}
 