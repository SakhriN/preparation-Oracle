{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang12  1. J. The code does not compile. In pattern matching switch statements, the order\par
 matters. In this example, line 47 dominates line 48, leading to unreachable code\par
 on line 48, and making option J the correct answer. For more information, see\par
 Chapter 3.\par
 2. B. Initially, moon is assigned a value of 9, while star is assigned a value of 8.\par
 The multiplication operator (*) has a higher order of precedence than the\par
 addition operator (+), so it gets evaluated first. Since star is not greater than 10,\par
 sun is assigned a value of 3, which is promoted to 3.0f as part of the\par
 assignment. The value of jupiter is (3.0f + 9) - 1.0, which is 11.0f. This\par
 value is implicitly promoted to double when it is assigned. In the last\par
 assignment, moon is decremented from 9 to 8, with the value of the expression\par
 returned as 8. Since 8 less than or equal to 8 is true, mars is set to a value of 2.\par
 The final output is 3.0, 11.0, 2, making option B the correct answer. Note\par
 that while Java outputs the decimal for both float and double values, it does\par
 not output the f for float values. For more information, see \par
Chapter 2.\par
 3. C, E. The Executors class has one factory method for working with virtual\par
 threads. It is newVirtualThreadPerTaskExecutor(), making option C correct.\par
 There is no constructor for virtual threads. There is a factory method\par
 Thread.ofVirtual(), making option E the other answer. For more information,\par
 see \par
Chapter 13.\par
 4. D. First, this mess of code does compile. However, the source is an infinite\par
 stream. The filter operation will check each element in turn to see whether any\par
 are not empty. While nothing passes the filter, the code does not terminate.\par
 Therefore, option D is correct. For more information, see \par
Chapter 10.\par
 5. B. The code compiles successfully, so options D and E are incorrect. The value\par
 of a cannot be changed by the addToInt() method, no matter what the method\par
 does, because only a copy of the variable is passed into the parameter x.\par
 Therefore, a does not change, and the output on line 9 is 15, which is option B.\par
 For more information, see \par
Chapter 5.\par
 6. C. Java will use Penguin_en.properties as the matching resource bundle on\par
 line 7. Since there is no match for French, the default locale is used. Line 8 finds\par
 a matching key in the Penguin_en.properties file. Line 9 does not find a\par
match in the Penguin_en.properties file; therefore, it has to look higher up in\par
 the hierarchy to Penguin.properties. This makes option C the answer. For\par
 more information, see \par
Chapter 11.\par
 7. D, E. The array is allowed to use an anonymous initializer because it is in the\par
 same line as the declaration. The results of the binary search are undefined since\par
 the array is not sorted. Since the question asks about guaranteed output, options\par
 A and B are incorrect. Option D is correct because the compare() method\par
 returns 0 when the arrays are the same length and have the same elements.\par
 Option E is correct because the mismatch() method returns a -1 when the\par
 arrays are equivalent. For more information, see \par
Chapter 4.\par
 8. C, E, F. First, note that option A is incorrect because the interface should be\par
 BiPredicate and not BinaryPredicate. Line 6 requires you to know that\par
 negate() is a convenience method on Predicate. This makes option E correct.\par
 Line 7 takes zero parameters and doesn\rquote t return anything, making it a Runnable.\par
 Remember that Runnable doesn\rquote t use generics. This makes option F correct.\par
 Finally, line 8 takes two parameters and returns an int. Option C is correct.\par
 Comparable is there to mislead you since it takes only one parameter in its\par
 single abstract method. For more information, see \par
Chapter 8.\par
 9. D. If this were a valid module-info.java file, it would need to be placed at the\par
 root directory of the module, which is option A. However, a module is not\par
 allowed to use the public access modifier. Option D is correct because the\par
 provided file does not compile regardless of placement in the project. For more\par
 information, see \par
Chapter 12.\par
 10. F, H. A method within an abstract class without an access modifier is considered\par
 to have package access. The class inherits the default method from the\par
 interface and is implicitly public, which means line 17 reduces the visibility of\par
 this access modifier. For this reason, line 17 does not compile and option F is\par
 correct. Line 23 also does not compile, as a local class can only access a local\par
 variable that is final or effectively final, making option H correct. If line 27\par
 were removed, then the variable would be effectively final and lines 22\f1\endash 24\par
 would compile. For more information, see \par
Chapter 7.\par
 11. C, E, F. The jump() method has package access, which means it can be accessed\par
 only from the same package. Tadpole is not in the same package as Frog,\par
 causing lines 7 and 10 to trigger compiler errors and giving us options C and F.\par
 The ribbit() method has protected access, which means it can only be\par
 accessed from a subclass reference or in the same package. Line 6 is fine\par
 because Tadpole is a subclass. Line 9 does not compile, and our final answer is\par
 option E because the variable reference is to a Frog, which doesn\rquote t grant access\par
 to the protected method. For more information, see \par
Chapter 5.\par
 12. C, D, E. The mySet declaration defines an upper bound of type\par
 RuntimeException. This means that classes may specify RuntimeException or\par
 any subclass of RuntimeException as the type parameter. Option B is incorrect\par
because Exception is a superclass, not a subclass, of RuntimeException.\par
 Options A and F are incorrect because the wildcard cannot occur on the right\par
 side of the assignment. Options C, D, and E compile and are the answers. For\par
 more information, see \par
Chapter 9.\par
 13. D, E. The declaration on lines 9\endash 11 includes an unhandled checked\par
 IOException, making option D correct. Line 12 does not compile because\par
 is.readObject() must be cast to a Bird object to be assigned to b. It also does\par
 not compile because it includes two unhandled checked exceptions,\par
 IOException and ClassNotFoundException, making option E correct. If a cast\par
 operation were added on line 12 and the main() method were updated on line 8\par
 to declare the various checked exceptions, the code would compile but throw an\par
 exception at runtime since Bird does not implement Serializable. Finally, if\par
 the class did implement Serializable, the program would print null at\par
 runtime, as that is the default value for the transient field age. For more\par
 information, see \par
Chapter 14.\par
 14. B. Line 14 does not compile because var is only allowed as a type for local\par
 variables, not instance members. Lines 15 and 18 do not compile because new\par
 and case are reserved words and cannot be used as identifiers. Line 16\par
 compiles, as var can be used as a method name. Line 17 does not compile\par
 because a single underscore (_) cannot be used as an identifier. Line 19 does not\par
 compile because var cannot be specified as the return type of a method. Since\par
 only one line compiles, option B is the answer. For more information, see\par
 Chapter 1.\par
 15. C, F. Option C is correct as mismatch() throws an exception if the files do not\par
 exist unless they both refer to the same file. Additionally, option F is correct\par
 because the first index that differs is returned, which is the second character.\par
 Since Java uses zero-based indexes, this is 1. For more information, see \par
Chapter\par
 14.\par
 16. F. The Amphibian class is marked final, which means line 3 triggers a compiler\par
 error and option F is correct. For more information, see \par
Chapter 6.\par
 17. C. The code compiles and runs without issue; therefore, options E and F are\par
 incorrect. This type of problem is best examined one loop iteration at a time:\par
 On the first iteration of the outer loop, i is 0, so the loop continues.\par
 On the first iteration of the inner loop, i is updated to 1 and x to 6. The if\par
 statement branch is not executed, and x is increased to 10 and j to 1.\par
 On the second iteration of the inner loop (since j = 1 and 1 <= 2), i is\par
 updated to 2 and x to 11. At this point, the if branch will evaluate to true\par
 for the remainder of the program run, which causes the flow to break out of\par
 the inner loop each time it is reached.\par
 On the second iteration of the outer loop (since i = 2), i is updated to 3 and\par
 x to 12. As before, the inner loop is broken since x is still greater than 10.\par
On the third iteration of the outer loop, the outer loop is broken, as i is\par
 already not less than 3. The most recent value of x, 12, is output, so the\par
 answer is option C.\par
 For more information, see \par
Chapter 3.\par
 18. C. First, note that the text block has the closing """ on a separate line, which\par
 means there is a new line at the end and rules out options D, E, and F.\par
 Additionally, text blocks don\rquote t start with a new line, ruling out options A and B.\par
 Therefore, option C is correct. For more information, see \par
Chapter 1.\par
 19. C. Only named modules are required to have a module-info.java file, ruling\par
 out options A, B, E, and F. Unnamed modules are not readable by any other\par
 types of modules, ruling out option D. Automatic modules always export all\par
 packages to other modules, making the answer option C. For more information,\par
 see \par
Chapter 12.\par
 20. I. The code compiles, so option G is incorrect. Line 26 does not throw an\par
 exception, as we are modifying the underlying collection, not the unmodifiable\par
 map, so option H is incorrect. Lines 27 and 28 each throw an\par
 UnsupportedOperationException (when run independently). TreeMap is a\par
 SequencedMap, so while it does inherit these methods, it does not support them.\par
 Doing so could break the ordering for the Comparator. For this reason, option I\par
 is correct. For more information, see \par
Chapter 9.\par
 21. C, F. Option A looks like a method reference. However, it doesn\rquote t call a valid\par
 method, nor can method references take parameters. The Predicate interface\par
 takes a single parameter and returns a boolean. Lambda expressions with one\par
 parameter are allowed, but not required, to omit the parentheses around the\par
 parameter list, making option C correct. The return statement is optional when\par
 a single statement is in the body, making option F correct. Option B is incorrect\par
 because a return statement must be used if braces are included around the\par
 body. Options D and E are incorrect because the type is Integer in the predicate\par
 and int in the lambda. Autoboxing works for collections, not inferring\par
 predicates. If these two were changed to Integer, they would be correct. For\par
 more information, see \par
Chapter 8.\par
 22. D. String literals are used from the string pool. This means that s1 and s2 refer\par
 to the same object and are equal. Therefore, the first two print statements print\par
 true. While the indent() and strip() methods create new String objects and\par
 the third statement prints false, the intern() method reverts the String to the\par
 one from the string pool. Therefore, the fourth print statement prints true. The\par
 fifth print statement prints false because toString() uses a method to compute\par
 the value, and it is not from the string pool. The final print statement again\par
 prints true because equals() looks at the values of String objects. Since four\par
 are true, option D is the answer. For more information, see \par
Chapter 4.\par
23. C. The Reindeer object is instantiated using the constructor that takes an int\par
 value. Since there is no explicit call to the parent constructor, the compiler\par
 inserts super() as the first line of the constructor on line 7. The parent\par
 constructor is called, and Deer is printed on line 2. The flow returns to the\par
 constructor on line 7, with Reindeer being printed. Next, the hasHorns()\par
 method is called. The reference type is Deer, and the underlying object type is\par
 Reindeer. Since Reindeer correctly overrides the hasHorns() method, the\par
 version in Reindeer is called, with line 11 printing ,true. Therefore, option C\par
 is correct. For more information, see \par
Chapter 6.\par
 24. B, F. Calling get() on an empty Optional causes an exception to be thrown,\par
 making option B correct. Option F is also correct because filter() makes the\par
 Optional empty before it calls get(). Option C is incorrect because the infinite\par
 stream is made finite by the intermediate limit() operation. Options A and E\par
 are incorrect because the source streams are not infinite. Therefore, the call to\par
 max() sees only three elements and terminates. For more information, see\par
 Chapter 10.\par
 25. C, D. Music does not compile because a record cannot contain instance\par
 variables that are not declared as part of the record. Song does not compile\par
 because a compact record constructor does not allow modifying an instance\par
 variable with a this reference. Dance does compile, making option C correct. A\par
 permits clause is optional for a sealed class if the associated classes are in the\par
 same file. March also compiles, making option D correct. A pattern matching\par
 switch can include elements of the record and use var. Ballet does not\par
 compile, as it is missing parentheses in the constructor. Remember, only records\par
 support compact constructors. NewDance also does not compile as a class that\par
 extends sealed classes must be marked final, sealed, or non-sealed. For more\par
 information, see \par
Chapter 7.\par
 26. B, D. Option A does not compile, as the expression 3 + 2.0 is evaluated as a\par
 double, and a double requires an explicit cast to be assigned to an int. Option\par
 B compiles without issue, as a long value can be implicitly cast to a double.\par
 Option C does not compile because the ternary operator (? :) is missing a colon\par
 (:), followed by a second expression. Option D is correct. Even though the int\par
 value is larger than a short, it is explicitly cast to a short, which means the\par
 value will wrap around to fit in a short. Option E is incorrect, as you cannot use\par
 a decimal (.) with the long (L) postfix. Finally, option F is incorrect, as an\par
 underscore cannot be used next to a decimal point. For more information, see\par
 Chapter 2.\par
 27. F. The code compiles without issue. The key to understanding this code is to\par
 notice that our thread executor contains only one thread, but our CyclicBarrier\par
 limit is 3. Even though 12 tasks are all successfully submitted to the service, the\par
 first task will block forever on the call to await(). Since the barrier is never\par
reached, nothing is printed, and the program hangs, making option F correct.\par
 For more information, see \par
Chapter 13.\par
 28. F. Line 5 does not compile as the FileNotFoundException thrown on line 12 is\par
 not handled or declared by the method. Line 7 does not compile because\par
 StringBuilder does not implement AutoCloseable and is therefore not\par
 compatible with a try-with-resource statement. Finally, line 10 does not compile\par
 as RuntimeException is a subclass of Exception in the multi-catch block,\par
 making it redundant. Since this method contains three compiler errors, option F\par
 is the correct answer. For more information, see \par
Chapter 11.\f0\par
}
 